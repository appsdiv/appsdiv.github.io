<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover,user-scalable=no"/>
    <title>Velocity — Polished Minimal Edition</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <link rel="apple-touch-icon" href="https://i.postimg.cc/D0r9rVjn/App-Icon-2x.png">
    <link rel="manifest" href="manifest.json">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        :root {
            --bg1: #07131f;
            --bg2: #0b1d33;
            --ink: #eaf4ff;
            --lane: rgba(220, 255, 255, .20);
            --ok: #16d07e;
            --warn: #ffd166;
            --danger: #ff5c93;
            --panel: #0d1117;
            --hudA: .9;
        }

        :root.hc {
            --lane: rgba(240, 255, 255, .38)
        }

        :root.cb-deu {
            --danger: #5465ff;
            --ok: #2ed573;
            --warn: #ffd166
        }

        :root.cb-pro {
            --danger: #00a0ff;
            --ok: #2ed573;
            --warn: #ffd166
        }

        :root.cb-tri {
            --danger: #ff5c93;
            --ok: #00c07a;
            --warn: #ffcc66
        }

        * {
            box-sizing: border-box
        }

        html, body {
            height: 100%;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        body {
            margin: 0;
            background: linear-gradient(180deg, var(--bg1), var(--bg2));
            color: var(--ink);
            font-family: 'Inter', system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            /* iPhone safe areas */
            padding: env(safe-area-inset-top, 0) env(safe-area-inset-right, 0) env(safe-area-inset-bottom, 0) env(safe-area-inset-left, 0);
        }

        /* Shell scales fixed game to fit any viewport (no layout shifts) */
        .shell {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center
        }

        .game {
            position: relative;
            width: 100vw;
            height: 100vh;
            border-radius: 0;
            overflow: hidden;
            border: none;
            box-shadow: none;
            transform-origin: center center;
            background: #0002
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%
        }

        /* Minimal HUD */
        .hud {
            position: absolute;
            top: env(safe-area-inset-top, 10px);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 30;
            pointer-events: none;
            opacity: var(--hudA)
        }

        .pill {
            background: rgba(0, 0, 0, .35);
            color: #fff;
            padding: 4px 9px;
            border-radius: 999px;
            font: 700 11px 'Inter';
            min-width: 64px;
            text-align: center;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, .2);
            box-shadow: 0 0 10px rgba(0, 0, 0, .2);
        }

        .pill .v {
            font-weight: 800
        }

        .health {
            position: absolute;
            top: env(safe-area-inset-top, 10px);
            left: env(safe-area-inset-left, 10px);
            width: 48%;
            height: 6px;
            border-radius: 999px;
            background: rgba(255, 255, 255, .12);
            overflow: hidden;
            backdrop-filter: blur(4px);
            z-index: 30;
            opacity: var(--hudA);
            border: 1px solid rgba(255, 255, 255, .2);
            box-shadow: 0 0 10px rgba(0, 0, 0, .2);
        }

        .health > span {
            display: block;
            height: 100%;
            background: linear-gradient(90deg, var(--ok), #7bffcb, #ffe66d, #ff9f43, #ff6b6b);
            transform-origin: left center;
            width: 100%
        }

        .mini {
            position: absolute;
            top: env(safe-area-inset-top, 10px);
            right: env(safe-area-inset-right, 10px);
            display: flex;
            gap: 6px;
            z-index: 31;
            opacity: var(--hudA)
        }

        .tag {
            background: rgba(0, 0, 0, .32);
            color: #fff;
            font: 700 10px 'Inter';
            padding: 4px 7px;
            border-radius: 9px;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, .2);
            box-shadow: 0 0 10px rgba(0, 0, 0, .2);
        }

        /* Buttons / Drawer */
        .btn {
            border: 0;
            border-radius: 14px;
            background: rgba(0, 0, 0, .46);
            color: #fff;
            padding: 9px 13px;
            font: 700 14px 'Exo 2', system-ui;
            backdrop-filter: blur(8px);
            box-shadow: 0 6px 18px rgba(0, 0, 0, .35);
            user-select: none;
            border: 1px solid rgba(255, 255, 255, .2);
        }

        .btn:active {
            transform: scale(.98)
        }

        .controls {
            position: absolute;
            left: 0;
            right: 0;
            bottom: env(safe-area-inset-bottom, 10px);
            display: flex;
            justify-content: space-between;
            padding: 0 10px;
            z-index: 35
        }

        .icon {
            position: absolute;
            top: env(safe-area-inset-top, 10px);
            right: calc(env(safe-area-inset-right, 10px) + 54px);
            z-index: 36
        }

        .icon2 {
            position: absolute;
            top: env(safe-area-inset-top, 10px);
            right: env(safe-area-inset-right, 10px);
            z-index: 36
        }

        .scrim {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, .35);
            backdrop-filter: blur(2px);
            z-index: 38;
            display: none
        }

        .scrim.show {
            display: block
        }

        .drawer {
            position: absolute;
            right: -360px;
            top: 0;
            height: 100%;
            width: 360px;
            background: var(--panel);
            color: #eef3ff;
            z-index: 999;
            box-shadow: -12px 0 28px rgba(0, 0, 0, .45);
            transition: right .25s ease;
            border-left: 1px solid rgba(255, 255, 255, .08);
            display: flex;
            flex-direction: column
        }

        .drawer.open {
            right: 0
        }

        .drawer header {
            position: relative;
            padding: 14px 48px 14px 16px;
            font-family: 'Exo 2';
            font-weight: 800;
            letter-spacing: .08em;
            border-bottom: 1px solid rgba(255, 255, 255, .08)
        }

        .drawer .closex {
            position: absolute;
            right: 10px;
            top: 8px;
            border-radius: 10px;
            padding: 6px 10px;
            background: rgba(255, 255, 255, .08);
            cursor: pointer
        }

        .drawer .sec {
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, .06)
        }

        .drawer label {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            align-items: center;
            font: 600 13px 'Inter';
            margin: 6px 0
        }

        .switch {
            appearance: none;
            width: 48px;
            height: 24px;
            background: #5b6572;
            border-radius: 999px;
            position: relative;
            outline: 0;
            cursor: pointer
        }

        .switch:checked {
            background: #13cc8b
        }

        .switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 18px;
            height: 18px;
            border-radius: 999px;
            background: #fff;
            transition: left .2s
        }

        .switch:checked::after {
            left: 27px
        }

        .sel, .input, .range {
            width: 100%;
            padding: 6px;
            margin-top: 6px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, .18);
            background: rgba(255, 255, 255, .06);
            color: #fff
        }

        .range {
            appearance: none;
            height: 10px;
            border: none
        }

        .range::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 0 0 2px rgba(0, 0, 0, .2)
        }

        .range::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #fff;
            border: none
        }

        /* Missions */
        .missions .row {
            display: flex;
            gap: 8px;
            align-items: center;
            margin: 6px 0
        }

        .mission-pill {
            display: inline-flex;
            gap: 6px;
            background: rgba(255, 255, 255, .06);
            border: 1px solid rgba(255, 255, 255, .12);
            padding: 6px 10px;
            border-radius: 10px;
            font: 600 12px 'Inter'
        }

        .progress {
            height: 6px;
            border-radius: 999px;
            background: rgba(255, 255, 255, .12);
            overflow: hidden;
            margin-left: auto;
            flex: 1
        }

        .progress > span {
            display: block;
            height: 100%;
            background: linear-gradient(90deg, #23d4ff, #4cff9f)
        }

        .mission-dot {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4d8d;
            box-shadow: 0 0 10px #ff4d8d;
            display: none
        }

        .mission-dot.show {
            display: block
        }

        /* Overlays */
        .gate, .over, .paused {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-family: 'Exo 2', system-ui;
            z-index: 40;
            text-align: center
        }

        .gate {
            background: rgba(0, 0, 0, .7);
            cursor: pointer
        }

        .over {
            background: rgba(0, 0, 0, .82);
            opacity: 0;
            pointer-events: none;
            transition: .25s
        }

        .over.show {
            opacity: 1;
            pointer-events: auto
        }

        .paused {
            background: rgba(0, 0, 0, .55);
            opacity: 0;
            pointer-events: none;
            transition: .2s
        }

        .paused.show {
            opacity: 1;
            pointer-events: auto
        }

        .title {
            font-size: 34px;
            letter-spacing: .18em;
            margin: 0 0 8px
        }

        .small {
            font: 400 12px 'Inter';
            opacity: .85
        }

        .badge {
            position: absolute;
            left: 50%;
            top: 16%;
            transform: translate(-50%, -50%) scale(.9);
            color: #fff;
            background: rgba(0, 0, 0, .55);
            padding: 8px 12px;
            border-radius: 10px;
            font: 700 13px 'Exo 2';
            opacity: 0;
            transition: all .35s cubic-bezier(.2, .9, .2, 1);
            backdrop-filter: blur(8px);
            z-index: 50;
            white-space: nowrap
        }

        .badge.show {
            top: 14%;
            opacity: 1;
            transform: translate(-50%, -50%) scale(1)
        }
    </style>
</head>
<body>
<div class="shell">
    <div class="game" id="game">
        <canvas id="cv"></canvas>

        <div class="health"><span id="hpFill"></span></div>
        <div class="hud">
            <div class="pill">Score <span class="v" id="score">0</span></div>
            <div class="pill">Speed <span class="v" id="spd">0</span></div>
            <div class="pill">Ammo <span class="v" id="ammo">120</span></div>
            <div class="pill" id="timerPill" style="display:none">Time <span class="v" id="timer">180</span></div>
        </div>
        <div class="mini">
            <div class="tag" id="focusTag">Focus: 0%</div>
            <div class="tag" id="empTag">EMP: 0%</div>
        </div>
        <div class="pill" id="radar"
             style="position: absolute; top: calc(env(safe-area-inset-top, 10px) + 36px); left: 50%; transform: translateX(-50%); pointer-events: none; backdrop-filter: none; background: transparent; min-width: 100px;">
            <span id="radar-text" style="display: block; width: 100%; text-align: center;"></span>
        </div>

        <button class="btn icon" id="drawerBtn" title="Settings">⚙️</button>
        <button class="btn icon2" id="muteBtn" title="Mute/Unmute">🔊</button>
        <div class="controls">
            <button class="btn" id="fireBtn" title="Hold to fire">🔫 Hold</button>
            <button class="btn" id="helpBtn">ℹ️</button>
        </div>

        <div class="scrim" id="scrim"></div>
        <div class="drawer" id="drawer">
            <header>Settings
                <button class="btn closex" id="closeDrawer" title="Close">✕</button>
            </header>
            <div class="sec">
                <label>Theme
                    <select class="sel" id="selTheme">
                        <option value="aurora">Aurora</option>
                        <option value="sunrise">Sunrise (Pink & Gold)</option>
                        <option value="tropical">Tropical</option>
                        <option value="neon">Neon City (Retro)</option>
                    </select>
                </label>
                <label>Theme Detail <input type="range" min="0" max="100" value="65" class="range"
                                           id="rngDetail"></label>
                <label>Theme Accent <input type="range" min="0" max="100" value="60" class="range"
                                           id="rngAccent"></label>
                <label>Vignette <input type="checkbox" class="switch" id="optVig" checked></label>
                <label>Speed Bloom <input type="checkbox" class="switch" id="optBloom" checked></label>
                <label>Rival Shooting <input type="checkbox" class="switch" id="optRival" checked></label>
                <label>Cloud Lightning <input type="checkbox" class="switch" id="optLightning" checked></label>
                <label>High Contrast Lanes <input type="checkbox" class="switch" id="optHC" checked></label>
                <label>Zen Mode (chill) <input type="checkbox" class="switch" id="optZen"></label>
                <label>Time Attack (3m) <input type="checkbox" class="switch" id="optTA"></label>
                <label>Ghost Replay <input type="checkbox" class="switch" id="optGhost"></label>
                <label>Low-Spec Mode <input type="checkbox" class="switch" id="optLow"></label>
                <label>Audio Preset
                    <select class="sel" id="selAudio">
                        <option value="off">Off</option>
                        <option value="soft" selected>Soft</option>
                        <option value="arcade">Arcade</option>
                    </select>
                </label>
                <label>Color-Blind Palette
                    <select class="sel" id="selCB">
                        <option value="none" selected>None</option>
                        <option value="deu">Deuteranopia</option>
                        <option value="pro">Protanopia</option>
                        <option value="tri">Tritanopia</option>
                    </select>
                </label>
                <label>Minimal HUD <input type="checkbox" class="switch" id="optMinimal" checked></label>
            </div>
            <div class="sec">
                <div style="font:700 13px 'Inter';margin:4px 0">Daily & Codes</div>
                <label>Daily Seed Mode <input type="checkbox" class="switch" id="optDaily" checked></label>
                <label>Challenge Code</label>
                <input class="input" id="codeIn" placeholder="Paste or generate…">
                <div style="display:flex;gap:8px;margin-top:6px">
                    <button class="btn" id="btnApply">Apply</button>
                    <button class="btn" id="btnGen">Generate</button>
                </div>
            </div>
            <div class="sec">
                <div style="font:700 13px 'Inter';margin:4px 0">Pilot Perks</div>
                <div style="font:600 12px 'Inter';opacity:.85;margin-bottom:6px">XP: <span id="xp">0</span> • Points: <span
                        id="pt">0</span></div>
                <label>+10 Ammo Cap <input type="checkbox" class="switch" id="perkAmmo"></label>
                <label>Faster Regen (+30%) <input type="checkbox" class="switch" id="perkRegen"></label>
                <label>Longer Boost (+40%) <input type="checkbox" class="switch" id="perkBoost"></label>
            </div>
            <div class="sec missions">
                <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px">
                    <div style="font-family:'Exo 2';font-weight:800">Missions</div>
                    <div class="mission-dot" id="missionDot"></div>
                </div>
                <div id="missionList"></div>
            </div>
        </div>

        <div class="gate" id="gate">
            <div>
                <div class="title">VELOCITY</div>
                <div class="small">Tap to Start • Swipe ◀ ▶ • ▲ accel • ▼ brake • Hold 🔫 / Space=fire • Q=Focus • E=EMP
                </div>
            </div>
        </div>
        <div class="over" id="over">
            <div class="title" style="letter-spacing:.1em">GAME OVER</div>
            <div class="small">Score: <b id="final">0</b> • Best: <b id="best">0</b></div>
            <button class="btn" id="again">Restart</button>
        </div>
        <div class="paused" id="paused">
            <div class="title" style="letter-spacing:.1em">PAUSED</div>
            <div class="small">Close ⚙️ or press Esc to resume</div>
        </div>
        <div class="badge" id="toast">+100</div>
    </div>
</div>

<script>
    (() => {
        "use strict";
        /* ---------- DOM ---------- */
        const $ = s => document.querySelector(s);
        const game = $("#game");
        const cv = $("#cv"), ctx = cv.getContext("2d", {alpha: true});
        const el = {
            score: $("#score"),
            spd: $("#spd"),
            ammo: $("#ammo"),
            hp: $("#hpFill"),
            gate: $("#gate"),
            over: $("#over"),
            final: $("#final"),
            best: $("#best"),
            toast: $("#toast"),
            drawer: $("#drawer"),
            missionList: $("#missionList"),
            missionDot: $("#missionDot"),
            timerPill: $("#timerPill"),
            timer: $("#timer"),
            focusTag: $("#focusTag"),
            empTag: $("#empTag"),
            xp: $("#xp"),
            pt: $("#pt"),
            scrim: $("#scrim"),
            paused: $("#paused"),
            radarText: $("#radar-text")
        };
        const btn = {
            again: $("#again"),
            mute: $("#muteBtn"),
            fire: $("#fireBtn"),
            help: $("#helpBtn"),
            drawer: $("#drawerBtn"),
            apply: $("#btnApply"),
            gen: $("#btnGen"),
            closeDrawer: $("#closeDrawer")
        };
        const sw = {
            rival: $("#optRival"),
            lightning: $("#optLightning"),
            hc: $("#optHC"),
            zen: $("#optZen"),
            ta: $("#optTA"),
            ghost: $("#optGhost"),
            low: $("#optLow"),
            daily: $("#optDaily"),
            minimal: $("#optMinimal"),
            vig: $("#optVig"),
            bloom: $("#optBloom")
        };
        const sel = {audio: $("#selAudio"), cb: $("#selCB"), theme: $("#selTheme")};
        const rngDetail = $("#rngDetail"), rngAccent = $("#rngAccent");
        const codeIn = $("#codeIn");
        const TAU = Math.PI * 2;
        /* ---------- Fit to viewport (desktop/mobile) ---------- */
        function fit() {
            const vw = window.innerWidth, vh = window.innerHeight;
            cv.width = vw;
            cv.height = vh;
            game.style.width = `${vw}px`;
            game.style.height = `${vh}px`;
            W = vw;
            H = vh;
            lanesX = Array.from({length: LANES}, (_, i) => (i + .5) * (W / LANES));
            if (player) {
                player.y = H - PLAYER_H - 56;
                player.x = lanesX[player.lane] - player.w / 2;
                player.tx = player.x;
            }
        }

        window.addEventListener('resize', fit);
        /* ---------- Seeds & Codes ---------- */
        function lcg(seed) {
            let s = seed | 0;
            return () => ((s = (s * 1664525 + 1013904223) | 0) >>> 0) / 4294967296;
        }

        function daySeed() {
            return +new Date().toISOString().slice(0, 10).replace(/-/g, '');
        }

        let mode = {daily: true, code: null};
        let R = Math.random;

        function applySeed() {
            if (mode.code) {
                const s = parseInt(mode.code.slice(0, 6), 36) || daySeed();
                R = lcg(s);
            } else if (mode.daily) {
                R = lcg(daySeed());
            } else R = Math.random;
        }

        function encodeCode() {
            const s = (daySeed() ^ ((sw.rival.checked ? 1 : 0) << 1) ^ ((sw.lightning.checked ? 1 : 0) << 2) ^ ((sw.zen.checked ? 1 : 0) << 3)) >>> 0;
            return (s >>> 0).toString(36).slice(0, 6).toUpperCase();
        }

        /* ---------- Persisted Settings ---------- */
        const SETTINGS = 'vel-polished-settings';
        let set = JSON.parse(localStorage.getItem(SETTINGS) || '{"theme":"aurora","detail":65,"accent":60,"vig":true,"bloom":true,"rival":true,"lightning":true,"hc":true,"zen":false,"ta":false,"ghost":false,"low":false,"audio":"soft","cb":"none","daily":true,"minimal":true}');

        function applySettingsUI() {
            sw.rival.checked = set.rival;
            sw.lightning.checked = set.lightning;
            sw.hc.checked = set.hc;
            sw.zen.checked = set.zen;
            sw.ta.checked = set.ta;
            sw.ghost.checked = set.ghost;
            sw.low.checked = set.low;
            sw.daily.checked = set.daily;
            sw.minimal.checked = set.minimal;
            sw.vig.checked = set.vig;
            sw.bloom.checked = set.bloom;
            sel.audio.value = set.audio;
            sel.cb.value = set.cb;
            sel.theme.value = set.theme;
            rngDetail.value = set.detail;
            rngAccent.value = set.accent;
            document.documentElement.classList.toggle('hc', !!set.hc);
            document.documentElement.classList.toggle('cb-deu', set.cb === 'deu');
            document.documentElement.classList.toggle('cb-pro', set.cb === 'pro');
            document.documentElement.classList.toggle('cb-tri', set.cb === 'tri');
            mode.daily = set.daily;
            applySeed();
            document.documentElement.style.setProperty('--hudA', set.minimal ? .88 : 1);
        }

        function saveSettings() {
            set = {
                theme: sel.theme.value,
                detail: +rngDetail.value,
                accent: +rngAccent.value,
                vig: sw.vig.checked,
                bloom: sw.bloom.checked,
                rival: sw.rival.checked,
                lightning: sw.lightning.checked,
                hc: sw.hc.checked,
                zen: sw.zen.checked,
                ta: sw.ta.checked,
                ghost: sw.ghost.checked,
                low: sw.low.checked,
                audio: sel.audio.value,
                cb: sel.cb.value,
                daily: sw.daily.checked,
                minimal: sw.minimal.checked
            };
            localStorage.setItem(SETTINGS, JSON.stringify(set));
            applySettingsUI();
            setThemeVars();
        }

        [sw.rival, sw.lightning, sw.hc, sw.zen, sw.ta, sw.ghost, sw.low, sw.daily, sw.minimal, sw.vig, sw.bloom].forEach(x => x.addEventListener('change', saveSettings));
        [sel.audio, sel.cb, sel.theme, rngDetail, rngAccent].forEach(x => x.addEventListener('input', saveSettings));
        /* ---------- Audio (gentle by default) ---------- */
        let audioArmed = false;
        const limiter = new Tone.Limiter(-6).toDestination();
        const master = new Tone.Gain(0.65).connect(limiter);
        const lowpass = new Tone.Filter(20000, "lowpass").connect(master);
        const ambience = new Tone.PolySynth(Tone.Synth).connect(new Tone.Gain(0.08).connect(lowpass));
        let ambOn = false;
        const quiet = () => sel.audio.value === 'off';

        function armAudio() {
            if (audioArmed || quiet()) return Promise.resolve();
            return Tone.start().then(() => audioArmed = true).catch(() => {
            });
        }

        const lastPlay = {coll: 0, score: 0, power: 0, pass: 0, shoot: 0, focus: 0, emp: 0};
        const minGap = {coll: .06, score: .05, power: .08, pass: .06, shoot: .03, focus: .2, emp: .3};

        function throttled(kind, fn) {
            if (quiet() || !audioArmed) return;
            const t = Tone.now();
            if (t - lastPlay[kind] < (minGap[kind] || .05)) return;
            lastPlay[kind] = t + 1e-4;
            fn(t + 1e-4);
        }

        let noiseColl, toneScore, fmPower, tonePass, shootSynth, toneFocus, toneEMP;

        function configureSynths() {
            if (sel.audio.value === 'off') return;
            const soft = sel.audio.value === 'soft';
            noiseColl = new Tone.NoiseSynth({
                noise: {type: "pink"},
                envelope: {attack: .001, decay: .14, sustain: 0, release: .05}
            }).connect(lowpass);
            toneScore = new Tone.Synth({
                oscillator: {type: soft ? 'sine' : 'square'},
                envelope: {attack: .001, decay: .06, sustain: 0, release: .06}
            }).connect(lowpass);
            fmPower = new Tone.FMSynth({
                harmonicity: 1.25,
                modulationIndex: soft ? 10 : 16,
                envelope: {attack: .01, decay: .16, release: .28}
            }).connect(lowpass);
            tonePass = new Tone.MonoSynth({
                oscillator: {type: soft ? 'triangle' : 'square'},
                envelope: {attack: .001, decay: .04, sustain: 0, release: .04}
            }).connect(lowpass);
            shootSynth = new Tone.MonoSynth({
                oscillator: {type: soft ? 'triangle' : 'sawtooth'},
                envelope: {attack: .001, decay: .05, sustain: 0, release: .04},
                filter: {type: "bandpass", Q: soft ? 6 : 10, frequency: soft ? 1100 : 1500},
                filterEnvelope: {
                    attack: .001,
                    decay: .05,
                    sustain: 0,
                    release: .04,
                    baseFrequency: soft ? 850 : 1100,
                    octaves: 2
                }
            }).connect(lowpass);
            toneFocus = new Tone.Synth({
                oscillator: {type: 'sine'},
                envelope: {attack: .001, decay: .12, sustain: 0, release: .12}
            }).connect(lowpass);
            toneEMP = new Tone.MonoSynth({
                oscillator: {type: 'square'},
                envelope: {attack: .001, decay: .1, sustain: 0, release: .08}
            }).connect(lowpass);
        }

        const sShoot = () => throttled('shoot', at => shootSynth.triggerAttackRelease('A6', '32n', at));
        const sColl = () => throttled('coll', at => noiseColl.triggerAttackRelease('8n', at));
        const sScore = () => throttled('score', at => toneScore.triggerAttackRelease('G5', '16n', at));
        const sPower = () => throttled('power', at => fmPower.triggerAttackRelease('A4', '8n', at));
        const sPass = () => throttled('pass', at => tonePass.triggerAttackRelease('E4', '16n', at));
        const sFocus = () => throttled('focus', at => toneFocus.triggerAttackRelease('C5', '8n', at));
        const sEMP = () => throttled('emp', at => toneEMP.triggerAttackRelease('E4', '8n', at));

        function tickAmbience(speed) {
            if (!audioArmed || quiet()) return;
            if (!ambOn) {
                ambience.set({oscillator: {type: 'sine'}, envelope: {attack: 2, release: 4}});
                ambience.triggerAttack(['C4', 'G4', 'D5']);
                ambOn = true;
            }
            const cutoff = 1800 + Math.min(14000, speed * 650);
            lowpass.frequency.rampTo(cutoff, .25);
        }

        /* ---------- Game constants ---------- */
        const LANES = 4, PLAYER_W = 42, PLAYER_H = 50;
        const BASE_SPEED = 2.6, MIN_SPEED = 1.4, MAX_SPEED = 200.0, ACCEL = 0.018, BRAKE = 0.015;
        let AMMO_MAX = 120, RECHARGE_MS = 8000, FIRE_MS = 90;
        let HP_MAX = 100, REGEN_DELAY = 400, REGEN_PER_S = 32, INV_MS = 1200;
        const NEAR = 54, COMBO_MS = 1500;
        const HYPERSONIC_SPEED = 50.0;
        /* Perks */
        const PERKS_KEY = 'vel-polished-perks';
        let perks = JSON.parse(localStorage.getItem(PERKS_KEY) || '{"ammo":false,"regen":false,"boost":false,"xp":0,"pts":0}');
        const pk = {ammo: $("#perkAmmo"), regen: $("#perkRegen"), boost: $("#perkBoost")};

        function applyPerks() {
            AMMO_MAX = 120 + (perks.ammo ? 10 : 0);
            REGEN_PER_S = 32 * (perks.regen ? 1.3 : 1.0);
            BOOST_BONUS = 2.1 * (perks.boost ? 1.4 : 1.0);
            el.xp.textContent = perks.xp | 0;
            el.pt.textContent = perks.pts | 0;
            pk.ammo.checked = perks.ammo;
            pk.regen.checked = perks.regen;
            pk.boost.checked = perks.boost;
        }

        function buyPerk(name) {
            if (perks[name] || perks.pts <= 0) return;
            perks[name] = true;
            perks.pts--;
            savePerks();
            applyPerks();
        }

        function savePerks() {
            localStorage.setItem(PERKS_KEY, JSON.stringify(perks));
        }

        [pk.ammo, pk.regen, pk.boost].forEach((E, i) => E.addEventListener('change', () => {
            const key = ['ammo', 'regen', 'boost'][i];
            if (!perks[key]) buyPerk(key);
            else E.checked = true;
        }));
        /* Missions */
        const MISS = 'vel-polished-missions';
        let missions = JSON.parse(localStorage.getItem(MISS) || '[]');

        function poolMissions() {
            const pool = [
                {id: 'weave5', label: 'Weave 5 near-misses', goal: 5, reward: 500},
                {id: 'speed4000', label: 'Reach 4000 km/h', goal: 1, reward: 600},
                {id: 'stars5', label: 'Collect 5 ⭐', goal: 5, reward: 400},
                {id: 'sonic3', label: 'Trigger 3 sonic booms', goal: 3, reward: 800},
                {id: 'draft6', label: 'Draft 6 times', goal: 6, reward: 450},
                {id: 'emp2', label: 'Use EMP 2 times', goal: 2, reward: 350},
                {id: 'focus8', label: 'Use Focus for 8s total', goal: 8, reward: 500}
            ];
            const rng = lcg(daySeed());
            const m = [];
            for (let i = 0; i < 4; i++) {
                const pick = pool.splice((rng() * pool.length) | 0, 1)[0];
                m.push({...pick, p: 0, done: false});
            }
            return m;
        }

        function renderMissions() {
            el.missionList.innerHTML = '';
            let pending = false;
            missions.forEach(m => {
                const row = document.createElement('div');
                row.className = 'row';
                const pill = document.createElement('div');
                pill.className = 'mission-pill';
                pill.textContent = m.label;
                const prog = document.createElement('div');
                prog.className = 'progress';
                const bar = document.createElement('span');
                bar.style.width = (100 * Math.min(1, (m.p || 0) / m.goal)) + '%';
                prog.appendChild(bar);
                const stat = document.createElement('div');
                stat.textContent = m.done ? '✓' : `${m.p || 0}/${m.goal}`;
                stat.style.marginLeft = '8px';
                if (m.done) stat.style.color = '#9effaa';
                row.appendChild(pill);
                row.appendChild(prog);
                row.appendChild(stat);
                el.missionList.appendChild(row);
                if (!m.done) pending = true;
            });
            el.missionDot.classList.toggle('show', pending);
            localStorage.setItem(MISS, JSON.stringify(missions));
        }

        function missionHit(id, inc = 1) {
            const m = missions.find(x => x.id === id);
            if (!m || m.done) return;
            m.p = Math.min(m.goal, (m.p || 0) + inc);
            if (m.p >= m.goal) {
                m.done = true;
                score += m.reward;
                toast(`Mission complete! +${m.reward}`);
            }
            renderMissions();
        }

        /* ---------- State ---------- */
        let W = 0, H = 0, lanesX = [];
        let raf = 0, running = false, paused = false;
        let speed = BASE_SPEED, accel = false, brake = false, firing = false;
        let score = 0, best = +localStorage.getItem('vel-polished-best') || 0;
        let ammo = AMMO_MAX, lastAmmo = 0, lastShot = 0;
        let hp = HP_MAX, lastHit = -1e9, invTil = 0;
        let sonic = false, sonicT = 0, sonicCount = 0, stars = 0;
        let weave = 0, lastSwap = -1e9, comboT = -1e9, mult = 1;
        let timer = 180000;
        let dtCarry = 0;
        let dualGun = false;
        let laneLockExpiry = 0;
        const TYPE = {RIVAL: 'rival', ACE: 'ace', HZ: 'haz', WEATHER: 'weather', LIGHT: 'light', PICK: 'pick'};
        const ents = [], bullets = [], eBullets = [], parts = [], clouds = [], lines = [];
        let player, ghost = [], ghostPlaying = [], ghostOn = false;
        let draftT = 0, focusEnergy = 0, focusOn = false, empEnergy = 0;
        let BOOST_BONUS = 2.1;
        const cam = {shake: 0, zoom: 1};
        let radarDistance = 0;
        let radarTarget = null;
        let dualGunExpiry = 0;
        /* ---------- Helpers ---------- */
        function toast(txt) {
            el.toast.textContent = txt;
            el.toast.classList.add('show');
            setTimeout(() => el.toast.classList.remove('show'), 1000);
        }

        function resize() {
            cv.width = W = window.innerWidth;
            cv.height = H = window.innerHeight;
            lanesX = Array.from({length: LANES}, (_, i) => (i + .5) * (W / LANES));
            if (player) {
                player.y = H - PLAYER_H - 56;
                player.x = lanesX[player.lane] - player.w / 2;
                player.tx = player.x;
            }
        }

        function buzz(ms = 12) {
            if (navigator.vibrate) try {
                navigator.vibrate(ms);
            } catch {
            }
        }

        const pick = a => a[(R() * a.length) | 0];
        /* ---------- Player ---------- */
        function makePlayer() {
            return {lane: (LANES / 2) | 0, x: 0, y: 0, w: PLAYER_W, h: PLAYER_H, bank: 0, tx: 0, smoke: 0}
        }

        /* ---------- Hazards (Simplified and Enhanced) ---------- */
        const HAZ = {
            // Orb Weaver
            orb: {
                dmg: 15, col: '#25deff', w: 20, h: 20, up: (e) => {
                    e.phase = (e.phase || 0) + 0.005;
                    e.x = lanesX[e.lane] - e.w / 2 + Math.sin(e.phase) * 20;
                }, dr: (e) => {
                    ctx.fillStyle = e.col;
                    ctx.beginPath();
                    ctx.arc(e.x + e.w / 2, e.y + e.h / 2, e.w / 2, 0, TAU);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255,255,255,.3)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            },
            // Energy Barrier
            energy_barrier: {
                dmg: 22, col: '#ff7a5a', w: 40, h: 40, dr: (e) => {
                    ctx.save();
                    ctx.translate(e.x + e.w / 2, e.y + e.h / 2);
                    ctx.rotate((performance.now() * 0.0005) % TAU);
                    ctx.fillStyle = e.col;
                    ctx.fillRect(-e.w / 2, -e.h / 2, e.w, e.h);
                    ctx.strokeStyle = 'rgba(255,255,255,.3)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-e.w / 2 + 2, -e.h / 2 + 2, e.w - 4, e.h - 4);
                    ctx.restore();
                }
            },
            // Vortex
            vortex: {
                dmg: 15, col: '#7c4dff', w: 40, h: 40, up: (e) => {
                    const dy = player.y - e.y;
                    if (Math.abs(dy) < 300) {
                        const pull = (300 - Math.abs(dy)) / 300 * 0.005;
                        player.x += (e.x - player.x) * pull;
                    }
                }, dr: (e) => {
                    ctx.strokeStyle = e.col;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(e.x + e.w / 2, e.y + e.h / 2, 18, 0, TAU);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(e.x + e.w / 2, e.y + e.h / 2, 12, 0, TAU);
                    ctx.stroke();
                }
            },
            // Laser
            laserH: {
                dmg: 28, col: '#fff2a8', w: W, h: 8, dr: (e) => {
                    ctx.fillStyle = e.col;
                    ctx.fillRect(0, e.y, W, 8);
                }
            },
            // Volts
            volt: {
                dmg: 32, col: '#ffe066', w: 6, h: 110, dr: (e) => {
                    ctx.strokeStyle = e.col;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    const x = e.x + 3;
                    ctx.moveTo(x, e.y);
                    for (let yy = 0; yy < e.h; yy += 10) ctx.lineTo(x + (R() - .5) * 10, e.y + yy);
                    ctx.stroke();
                }
            },
            // Rotor Blades
            rotor: {
                dmg: 28, col: '#dcdcdc', w: 32, h: 32, up: (e, dt) => {
                    e.rot = (e.rot || 0) + dt * 0.02;
                }, dr: (e) => {
                    ctx.save();
                    ctx.translate(e.x + 16, e.y + 16);
                    ctx.rotate(e.rot || 0);
                    ctx.fillStyle = '#dcdcdc';
                    for (let i = 0; i < 8; i++) {
                        ctx.rotate(TAU / 8);
                        ctx.beginPath();
                        ctx.moveTo(0, -16);
                        ctx.lineTo(6, -8);
                        ctx.lineTo(0, 0);
                        ctx.closePath();
                        ctx.fill();
                    }
                    ctx.restore();
                }
            },
            // Splitter
            splitter: {
                dmg: 20, col: '#ff9900', w: 30, h: 30, up: (e) => {
                    if (e.y > H / 2 && !e.split) {
                        e.split = true;
                        explode(e);
                        ents.push({
                            ...e,
                            y: e.y + 20,
                            sp: e.sp + 0.5,
                            x: e.x - 15,
                            w: 15,
                            h: 15,
                            dmg: 10,
                            dead: false
                        });
                        ents.push({
                            ...e,
                            y: e.y + 20,
                            sp: e.sp + 0.5,
                            x: e.x + 15,
                            w: 15,
                            h: 15,
                            dmg: 10,
                            dead: false
                        });
                        e.dead = true;
                    }
                }, dr: (e) => {
                    ctx.fillStyle = e.col;
                    ctx.fillRect(e.x, e.y, e.w, e.h);
                }
            },
            // Pulsar
            pulsar: {
                dmg: 10, col: '#ff5c93', w: 20, h: 20, up: (e) => {
                    e.pulse = (e.pulse || 0) + 0.05;
                    if (e.pulse > TAU) e.pulse = 0;
                    e.radius = 10 + Math.sin(e.pulse) * 5;
                    if (e.pulse > 0 && e.pulse < 0.1) {
                        if (player && aabb(e, player)) damage(e.dmg);
                    }
                }, dr: (e) => {
                    ctx.fillStyle = e.col;
                    ctx.beginPath();
                    ctx.arc(e.x + e.w / 2, e.y + e.h / 2, e.radius, 0, TAU);
                    ctx.fill();
                }
            },
            // Train
            train: {
                dmg: 34, col: '#444', w: 40, h: 140, dr: (e) => {
                    ctx.fillStyle = e.col;
                    ctx.fillRect(e.x, e.y, e.w, e.h);
                }
            },
            // Ion Pulse - New beautiful obstacle
            ion_pulse: {
                dmg: 5, col: '#00ffc8', w: 60, h: 60, dr: (e) => {
                    const cx = e.x + e.w / 2;
                    const cy = e.y + e.h / 2;
                    const t = performance.now();
                    ctx.save();
                    ctx.globalAlpha = 0.5 + Math.sin(t * 0.005) * 0.2;
                    ctx.strokeStyle = e.col;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(cx, cy, 20 + Math.sin(t * 0.002) * 5, 0, TAU);
                    ctx.stroke();
                    ctx.globalAlpha = 0.2 + Math.cos(t * 0.005) * 0.1;
                    ctx.beginPath();
                    ctx.arc(cx, cy, 10 + Math.cos(t * 0.003) * 3, 0, TAU);
                    ctx.stroke();
                    ctx.restore();
                }
            },
            // Saw Blade - New spinning obstacle
            saw_blade: {
                dmg: 25, col: '#ff5c93', w: 30, h: 30, up: (e, dt) => {
                    e.rot = (e.rot || 0) + dt * 0.05;
                }, dr: (e) => {
                    const cx = e.x + e.w / 2;
                    const cy = e.y + e.h / 2;
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.rotate(e.rot || 0);
                    ctx.fillStyle = e.col;
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * TAU;
                        const innerAngle = angle + (TAU / 16);
                        ctx.lineTo(15 * Math.cos(angle), 15 * Math.sin(angle));
                        ctx.lineTo(8 * Math.cos(innerAngle), 8 * Math.sin(innerAngle));
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                }
            }
        };
        const HAZ_KEYS = Object.keys(HAZ);
        let fogT = 0, windX = 0, slipT = 0;
        /* ---------- Pickups ---------- */
        const PICKS = {
            hp: {
                col: '#2dd36f', apply: () => {
                    hp = Math.min(HP_MAX, hp + 26);
                    el.hp.style.transform = `scaleX(${hp / HP_MAX})`;
                    toast('HP +');
                    sColl();
                }
            },
            ammo: {
                col: '#74c0fc', apply: () => {
                    ammo = Math.min(AMMO_MAX, ammo + Math.ceil(AMMO_MAX * 0.5));
                    el.ammo.textContent = ammo;
                    toast('Ammo +');
                    sShoot();
                }
            },
            score: {
                col: '#ffd43b', apply: () => {
                    const add = 200 * mult;
                    score += add;
                    toast(`Score +${add}`);
                    sScore();
                }
            },
            focus: {
                col: '#66d9e8', apply: () => {
                    focusEnergy = Math.min(1, focusEnergy + .35);
                    toast('Focus +');
                    sFocus();
                }
            },
            emp: {
                col: '#ffa94d', apply: () => {
                    empEnergy = Math.min(1, empEnergy + .5);
                    toast('EMP +');
                    sEMP();
                }
            },
            dualgun: {
                col: '#ff00c8', apply: () => {
                    dualGun = true;
                    toast('Dual Guns Activated!');
                    dualGunExpiry = performance.now() + 8000;
                }
            },
            cosmic_crate: {
                col: '#ff00ff', apply: () => {
                    const bonuses = ['score', 'ammo', 'hp', 'dualgun', 'emp'];
                    const bonus = pick(bonuses);
                    if (bonus === 'score') {
                        const add = 2000 * mult;
                        score += add;
                        toast(`Cosmic Crate! Massive Score +${add}`);
                    } else {
                        PICKS[bonus].apply();
                        toast(`Cosmic Crate! Found a bonus: ${bonus}`);
                    }
                }
            },
            coin: {
                col: '#ffdd00', apply: () => {
                    score += 10;
                    sScore();
                    toast('+10 coins');
                }
            },
            star: {
                col: '#ffdd00', apply: () => {
                    score += 50;
                    sScore();
                    toast('+50 stars');
                }
            },
            trophy: {
                col: '#c8a956', apply: () => {
                    score += 2000;
                    sScore();
                    toast('Trophy! +2000 bonus');
                }
            },
            invincibility: {
                col: '#00ffff', apply: () => {
                    invTil = performance.now() + 5000;
                    toast('Invincibility!');
                }
            },
        };

        function spawnPickupAt(x, y) {
            const pickups = Object.keys(PICKS);
            // Adjusted probabilities for new items
            const probabilities = {
                hp: 0.1,
                ammo: 0.1,
                focus: 0.1,
                emp: 0.1,
                dualgun: 0.05,
                cosmic_crate: 0.02,
                invincibility: 0.02,
                coin: 0.3,
                star: 0.2,
                trophy: 0.01
            };
            let rand = R();
            let key;
            for (const p of pickups) {
                rand -= probabilities[p];
                if (rand <= 0) {
                    key = p;
                    break;
                }
            }
            // FIX: Ensure key is not undefined before pushing to ents
            if (!key) {
                key = 'coin'; // Default to a safe pickup
            }
            const e = {kind: TYPE.PICK, pk: key, x: x - 10, y: y - 10, w: 20, h: 20, vy: 2.2 + R() * 1.4, t: 0, a: 1};
            ents.push(e);
        }

        function drawPickup(e) {
            // FIX: Added a safety check to handle potential undefined items gracefully
            const itemData = PICKS[e.pk];
            if (!itemData) return;
            const c = itemData.col;
            ctx.save();
            ctx.globalAlpha = e.a;
            ctx.fillStyle = c;
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 1;
            const cx = e.x + e.w / 2, cy = e.y + e.h / 2;
            ctx.beginPath();
            if (e.pk === 'hp') { // plus
                ctx.fillRect(cx - 8, cy - 2, 16, 4);
                ctx.fillRect(cx - 2, cy - 8, 4, 16);
            } else if (e.pk === 'ammo') { // bullet
                ctx.beginPath();
                ctx.moveTo(cx - 4, cy + 6);
                ctx.lineTo(cx + 4, cy + 6);
                ctx.lineTo(cx + 4, cy - 2);
                ctx.quadraticCurveTo(cx, cy - 8, cx - 4, cy - 2);
                ctx.closePath();
                ctx.fill();
            } else if (e.pk === 'score') { // star
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const ang = (i * 72 - 90) * Math.PI / 180;
                    const ang2 = ((i * 72 + 36) - 90) * Math.PI / 180;
                    ctx.lineTo(cx + 8 * Math.cos(ang), cy + 8 * Math.sin(ang));
                    ctx.lineTo(cx + 4 * Math.cos(ang2), cy + 4 * Math.sin(ang2));
                }
                ctx.closePath();
                ctx.fill();
            } else if (e.pk === 'focus') { // circle
                ctx.beginPath();
                ctx.arc(cx, cy, 7, 0, TAU);
                ctx.fill();
            } else if (e.pk === 'emp') { // bolt
                ctx.beginPath();
                ctx.moveTo(cx - 4, cy - 6);
                ctx.lineTo(cx + 1, cy - 2);
                ctx.lineTo(cx - 2, cy - 2);
                ctx.lineTo(cx + 4, cy + 6);
                ctx.lineTo(cx - 1, cy + 2);
                ctx.lineTo(cx + 2, cy + 2);
                ctx.closePath();
                ctx.fill();
            } else if (e.pk === 'dualgun') { // twin bullets
                ctx.fillRect(cx - 6, cy, 3, 10);
                ctx.fillRect(cx + 3, cy, 3, 10);
            } else if (e.pk === 'cosmic_crate') { // box
                ctx.fillStyle = '#ff00ff';
                ctx.strokeStyle = '#fff';
                ctx.fillRect(cx - 10, cy - 10, 20, 20);
                ctx.beginPath();
                ctx.moveTo(cx - 5, cy);
                ctx.lineTo(cx + 5, cy);
                ctx.moveTo(cx, cy - 5);
                ctx.lineTo(cx, cy + 5);
                ctx.stroke();
            } else if (e.pk === 'coin') { // Coin
                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.arc(cx, cy, 8, 0, TAU);
                ctx.fill();
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#fff';
                ctx.strokeText('C', cx - 3, cy + 4);
            } else if (e.pk === 'star') { // Star
                ctx.beginPath();
                ctx.moveTo(cx, cy - 8);
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 72 - 90) * Math.PI / 180;
                    const innerAngle = ((i * 72 + 36) - 90) * Math.PI / 180;
                    ctx.lineTo(cx + 8 * Math.cos(angle), cy + 8 * Math.sin(angle));
                    ctx.lineTo(cx + 4 * Math.cos(innerAngle), cy + 4 * Math.sin(innerAngle));
                }
                ctx.closePath();
                ctx.fillStyle = c;
                ctx.fill();
            } else if (e.pk === 'trophy') { // Trophy
                ctx.fillStyle = c;
                ctx.beginPath();
                ctx.moveTo(cx - 10, cy);
                ctx.lineTo(cx + 10, cy);
                ctx.lineTo(cx + 10, cy - 5);
                ctx.arc(cx, cy - 5, 10, 0, Math.PI, true);
                ctx.lineTo(cx - 10, cy - 5);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.rect(cx - 5, cy, 10, 5);
                ctx.fill();
            } else if (e.pk === 'invincibility') { // invincibility
                ctx.beginPath();
                ctx.arc(cx, cy, 10, 0, TAU);
                ctx.fillStyle = c;
                ctx.fill();
            }
            ctx.restore();
        }

        /* ---------- Spawns & Director ---------- */
        function laneX(l) {
            return lanesX[l];
        }

        function pushHaz(key, l, y) {
            const h = HAZ[key], w = h.w, hh = h.h;
            if (!h) {
                console.error(`Attempted to spawn unknown hazard type: ${key}`);
                return;
            }
            const e = {
                kind: TYPE.HZ,
                hz: key,
                lane: l,
                x: laneX(l) - w / 2,
                y,
                w,
                h: hh,
                sp: 1.6 + R() * 1.2 + speed * .08,
                col: h.col,
                hp: h.hp || 0
            };
            ents.push(e);
        }

        function spawnHazard(l, y) {
            const k = pick(HAZ_KEYS);
            if (k === 'laserH') {
                ents.push({
                    kind: TYPE.HZ,
                    hz: 'laserH',
                    lane: l,
                    x: 0,
                    y: y,
                    w: W,
                    h: 8,
                    sp: 2.6 + speed * .3,
                    col: HAZ.laserH.col
                });
                return;
            }
            if (k === 'volt') {
                const x = laneX(l);
                ents.push({
                    kind: TYPE.HZ,
                    hz: 'volt',
                    lane: l,
                    x: x - 3,
                    y: y,
                    w: 6,
                    h: 110,
                    sp: 3 + speed * .35,
                    col: HAZ.volt.col
                });
                return;
            }
            pushHaz(k, l, y);
        }

        function spawnRival(l, y) {
            const w = 38, h = 46;
            ents.push({
                kind: TYPE.RIVAL,
                lane: l,
                x: laneX(l) - w / 2,
                y,
                w,
                h,
                sp: 2 + R() * 2 + speed * .15,
                color: pick(['#ff3b3b', '#ff9f1a', '#4ca3ff', '#19c997', '#c56cf0']),
                shot: 800 + R() * 900,
                passed: false,
                targetLane: l
            });
        }

        function spawnAce() {
            const l = (R() * LANES) | 0, y = -120, w = 52, h = 58;
            ents.push({
                kind: TYPE.ACE,
                lane: l,
                x: laneX(l) - w / 2,
                y,
                w,
                h,
                sp: 2 + R() * 1.5 + speed * .12,
                hp: 5,
                color: '#ffd166',
                shot: 500,
                phase: 0
            });
        }

        const director = {mode: 'free', t: 0, dur: 0, wave: 0};

        function setPattern(name, dur = 6000) {
            director.mode = name;
            director.dur = dur;
            director.t = 0;
        }

        let spawnAcc = 0, aceAcc = 0, patternAcc = 0;

        function patternSpawn(dt) {
            director.t += dt;
            if (director.t > director.dur) {
                director.mode = 'free';
            }
            if (director.mode === 'free') {
                const difficulty = score / 10000;
                if (patternAcc > (4000 + R() * 2000) * (1 - Math.min(0.5, difficulty))) {
                    patternAcc = 0;
                    const patterns = ['zigzag', 'orb', 'vortex_trap', 'train_line', 'ion_pulse', 'saw_blade_field'];
                    setPattern(pick(patterns), 2000 + R() * 2000);
                }
            }
            if (director.mode === 'convoy') {
                if ((director.t | 0) % 300 < 18) {
                    const l = (R() * LANES) | 0;
                    for (let k = 0; k < 3; k++) spawnRival(l, -120 - k * 70);
                }
            } else if (director.mode === 'zigzag') {
                if ((director.t | 0) % 220 < 18) {
                    const start = (R() * 4) | 0;
                    for (let i = 0; i < 4; i++) {
                        const l = (start + i) % 4;
                        pushHaz('energy_barrier', l, -120 - i * 55);
                    }
                }
            } else if (director.mode === 'orb') {
                if ((director.t | 0) % 280 < 18) {
                    for (let l = 0; l < LANES; l++) pushHaz('orb', l, -100 - l * 40);
                }
            } else if (director.mode === 'train_line') {
                if ((director.t | 0) % 500 < 18) {
                    const l = (R() * LANES) | 0;
                    pushHaz('train', l, -200);
                    pushHaz('train', l, -350);
                }
            } else if (director.mode === 'ion_pulse') {
                if ((director.t | 0) % 300 < 18) {
                    const l = (R() * LANES) | 0;
                    pushHaz('ion_pulse', l, -100);
                }
            } else if (director.mode === 'saw_blade_field') {
                if ((director.t | 0) % 150 < 18) {
                    const l = (R() * LANES) | 0;
                    pushHaz('saw_blade', l, -100);
                }
            } else if (director.mode === 'safe') {
                if ((director.t | 0) % 260 < 18) {
                    const safe = (R() * 4) | 0;
                    for (let l = 0; l < LANES; l++) {
                        if (l !== safe) pushHaz(pick(HAZ_KEYS), l, -110);
                    }
                }
            }
        }

        function spawnStep(dt) {
            spawnAcc += dt;
            aceAcc += dt;
            patternAcc += dt;
            const base = (set.zen ? 650 : 400) - speed * 20 - score * 0.04;
            if (spawnAcc > Math.max(120, base) && director.mode === 'free') {
                spawnAcc = 0;
                const lanes = [0, 1, 2, 3];
                const count = 2 + (R() < Math.min(1, score / 1000) ? 1 : 0);
                for (let k = 0; k < count; k++) {
                    const l = lanes.splice((R() * lanes.length) | 0, 1)[0];
                    const y = -80 - k * 60;
                    const r = R();
                    // Increased rival spawn chance
                    const rivalChance = 0.8 + Math.min(0.7, speed / 100) + Math.min(0.4, score / 5000);
                    if (r < rivalChance && sw.rival.checked) spawnRival(l, y);
                    else {
                        const pickupChance = R();
                        if (pickupChance < 0.35) { // Increased chance for pickups
                            spawnPickupAt(laneX(l), y);
                        } else {
                            pushHaz(pick(HAZ_KEYS), l, y);
                        }
                    }
                }
            }
            if (!set.zen && aceAcc > (25000 - Math.min(20000, score * 5))) {
                aceAcc = 0;
                spawnAce();
            }
            clouds.forEach((c, i) => {
                c.y += (c.v + speed * .1);
                c.x += Math.sin((performance.now() + i * 900) / 2600) * .12;
                if (c.y > H + 40) {
                    c.y -= H + 80;
                    c.x = (c.x + W) % W;
                }
            });
        }

        /* ---------- Bullets ---------- */
        function fire() {
            const t = performance.now();
            if (ammo <= 0 || t - lastShot < FIRE_MS) return;
            lastShot = t;
            ammo--;
            el.ammo.textContent = ammo;
            sShoot();
            if (dualGun) {
                bullets.push({
                    x: player.x + player.w / 2 - 10,
                    y: player.y - 12,
                    w: 7,
                    h: 22,
                    sp: 18 + speed * 1.2,
                    trail: 10,
                    color: '#ff0000',
                    glow: '#ff5c00'
                });
                bullets.push({
                    x: player.x + player.w / 2 + 3,
                    y: player.y - 12,
                    w: 7,
                    h: 22,
                    sp: 18 + speed * 1.2,
                    trail: 10,
                    color: '#ff0000',
                    glow: '#ff5c00'
                });
            } else {
                bullets.push({
                    x: player.x + player.w / 2 - 3,
                    y: player.y - 12,
                    w: 7,
                    h: 22,
                    sp: 18 + speed * 1.2,
                    trail: 10,
                    color: '#ff0000',
                    glow: '#ff5c00'
                });
            }
        }

        /* ---------- Collisions / Damage ---------- */
        function aabb(a, b) {
            return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + b.h > b.y;
        }

        function damage(d) {
            const t = performance.now();
            if (t < invTil) return;
            hp = Math.max(0, hp - d);
            el.hp.style.transform = `scaleX(${hp / HP_MAX})`;
            lastHit = t;
            invTil = t + INV_MS;
            cam.shake = Math.max(cam.shake, 14);
            sColl();
            buzz(12);
        }

        /* ---------- Theme Backgrounds (with Accent) ---------- */
        const themeDef = {
            aurora: {
                bg1: '#07131f',
                bg2: '#0b1d33',
                ribbons: ['rgba(0,220,255,.16)', 'rgba(0,255,160,.12)', 'rgba(255,80,180,.10)'],
                lane: 'rgba(200,255,255,.18)'
            },
            sunrise: {
                bg1: '#0e1833',
                bg2: '#ffb77a',
                ribbons: ['rgba(255,210,150,.18)', 'rgba(255,128,160,.16)', 'rgba(255,255,255,.08)'],
                lane: 'rgba(50,20,0,.20)'
            },
            tropical: {
                bg1: '#042a2a',
                bg2: '#00a88b',
                ribbons: ['rgba(0,255,200,.18)', 'rgba(0,200,120,.12)', 'rgba(255,255,255,.08)'],
                lane: 'rgba(0,40,40,.22)'
            },
            neon: {bg1: '#0b0b18', bg2: '#141436', ribbons: [], lane: 'rgba(140,220,255,.22)'}
        };

        function setThemeVars() {
            const th = themeDef[sel.theme.value] || themeDef.aurora;
            document.documentElement.style.setProperty('--bg1', th.bg1);
            document.documentElement.style.setProperty('--bg2', th.bg2);
            document.documentElement.style.setProperty('--lane', th.lane);
        }

        function seedClouds() {
            clouds.length = 0;
            const n = Math.round((set.detail / 100) * (set.low ? 10 : 22));
            for (let i = 0; i < n; i++) clouds.push({x: R() * W, y: R() * H, r: 18 + R() * 30, v: .20 + .05 * R(), a: .9});
        }

        function bgAurora(t) {
            const bands = Math.max(2, Math.round(3 * set.detail / 100));
            for (let b = 0; b < bands; b++) {
                const amp = (16 + 10 * b) * (set.detail / 65), y0 = H * .25 + .12 * b * H, spd = 0.00018 * (b + 1);
                ctx.beginPath();
                ctx.moveTo(0, y0);
                for (let x = 0; x <= W; x += 14) {
                    const y = y0 + Math.sin(x * 0.01 + t * spd + b) * amp + Math.sin(x * 0.004 - t * spd * 1.3 + b) * amp * .6;
                    ctx.lineTo(x, y);
                }
                ctx.lineTo(W, H);
                ctx.lineTo(0, H);
                ctx.closePath();
                ctx.fillStyle = themeDef.aurora.ribbons[b % themeDef.aurora.ribbons.length];
                ctx.fill();
            }
        }

        function bgSunrise(t) {
            const mag = set.accent / 100;
            const sunY = H * 0.62, sunX = W * 0.5, r = 70 + 40 * (set.detail / 100);
            const g = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, r * 2.2);
            g.addColorStop(0, 'rgba(255,230,180,.45)');
            g.addColorStop(1, 'rgba(255,170,120,0)');
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(sunX, sunY, r * 2.4, 0, TAU);
            ctx.fill();
            const n = 10 + Math.round(10 * (set.detail / 100));
            ctx.save();
            ctx.translate(sunX, sunY);
            ctx.globalAlpha = .12;
            for (let i = 0; i < n; i++) {
                const ang = (i / n) * TAU + (t * 0.00005);
                ctx.rotate(ang);
                ctx.fillStyle = 'rgba(255,200,160,.9)';
                ctx.fillRect(0, -2, W, 4);
                ctx.rotate(-ang);
            }
            ctx.restore();
            const cN = Math.round(10 * (set.detail / 100));
            for (let i = 0; i < cN; i++) {
                const cx = (i / cN) * W + Math.sin((t / 8000) + i) * 40, cy = H * .48 + Math.sin((t / 3000) + i) * 8;
                const col = `rgba(${Math.round(255 * (0.7 + 0.3 * mag))},${Math.round(160 * (1 - mag) + 90 * mag)},${Math.round(170 * (1 - mag) + 220 * mag)},0.35)`;
                ctx.fillStyle = col;
                ctx.beginPath();
                ctx.ellipse(cx, cy, 46, 24, 0, 0, TAU);
                ctx.fill();
            }
        }

        function bgTropical(t) {
            const br = set.accent / 100;
            ctx.fillStyle = `rgba(${Math.round(0 + 80 * br)},${Math.round(200 + 40 * br)},${Math.round(180 + 60 * br)},.12)`;
            ctx.fillRect(0, H * .62, W, H * .38);
            const count = 3 + Math.round(3 * (set.detail / 100));
            ctx.save();
            ctx.globalAlpha = .35;
            ctx.fillStyle = '#042013';
            for (let i = 0; i < count; i++) {
                const px = (i / (count - 1)) * W + Math.sin(t * 0.0002 + i) * 20;
                ctx.fillRect(px - 6, H * .8, 12, H * .3);
                for (let k = 0; k < 6; k++) {
                    const a = (k / 5) * Math.PI - Math.PI / 2, len = 60 + 10 * (k % 2);
                    ctx.beginPath();
                    ctx.moveTo(px, H * .8);
                    ctx.lineTo(px + Math.cos(a) * len, H * .8 + Math.sin(a) * len);
                    ctx.strokeStyle = '#042013';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }
            ctx.restore();
            const waves = 6 + Math.round(6 * (set.detail / 100));
            ctx.globalAlpha = .14;
            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < waves; i++) {
                const y = H * .78 + i * 10 + Math.sin(t * 0.001 + i) * 4;
                ctx.fillRect(0, y, W, 1.2);
            }
            ctx.globalAlpha = 1;
        }

        function bgNeon(t) {
            const dens = 0.6 + 1.2 * (set.accent / 100);
            const horizon = H * 0.72;
            ctx.save();
            ctx.globalAlpha = .18;
            ctx.strokeStyle = '#00e1ff';
            ctx.lineWidth = 1;
            const cols = Math.round((18 + 10 * (set.detail / 100)) * dens);
            for (let i = 0; i <= cols; i++) {
                const u = i / cols;
                const x = (u - 0.5) * W * 1.6;
                ctx.beginPath();
                ctx.moveTo(W / 2 + x, horizon);
                ctx.lineTo(W / 2 + x * 0.1, H);
                ctx.stroke();
            }
            const rows = Math.round((12 + 10 * (set.detail / 100)) * dens);
            for (let r = 1; r <= rows; r++) {
                const y = horizon + (H - horizon) * (r / rows) * (r / rows);
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(W, y);
                ctx.stroke();
            }
            ctx.restore();
            ctx.save();
            ctx.globalAlpha = .45;
            ctx.fillStyle = '#16164a';
            const bcount = Math.round((8 + 6 * (set.detail / 100)) * dens);
            for (let i = 0; i < bcount; i++) {
                const baseY = horizon - 20 - ((i % 3) * 14);
                const bx = (i * (W / bcount)) * 1.02 % (W + 60) - 30;
                const bw = 36 + ((i * 13) % 50), bh = 60 + ((i * 23) % 80);
                ctx.fillRect(bx, baseY - bh, bw, bh);
                ctx.globalAlpha = .22;
                ctx.strokeStyle = '#ff00c8';
                ctx.lineWidth = 2;
                ctx.strokeRect(bx + 0.5, baseY - bh + 0.5, bw - 1, bh - 1);
                ctx.globalAlpha = .45;
                ctx.fillStyle = '#16164a';
            }
            ctx.restore();
        }

        function drawBackground(t) {
            const th = themeDef[sel.theme.value] || themeDef.aurora;
            const g = ctx.createLinearGradient(0, 0, 0, H);
            g.addColorStop(0, th.bg1);
            g.addColorStop(1, th.bg2);
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, W, H);
            if (sel.theme.value === 'aurora') bgAurora(t);
            else if (sel.theme.value === 'sunrise') bgSunrise(t);
            else if (sel.theme.value === 'tropical') bgTropical(t);
            else if (sel.theme.value === 'neon') bgNeon(t);
            const cAlpha = .75 * (set.detail / 100);
            clouds.forEach(cl => {
                ctx.globalAlpha = cAlpha;
                ctx.fillStyle = 'rgba(255,255,255,.96)';
                ctx.beginPath();
                ctx.ellipse(cl.x, cl.y, cl.r * 1.3, cl.r, 0, 0, TAU);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function drawLanes() {
            ctx.globalAlpha = set.hc ? 0.24 : 0.16;
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--lane');
            for (let i = 1; i < LANES; i++) {
                const x = i * W / LANES;
                ctx.fillRect(x - 1, 0, 2, H);
            }
            ctx.globalAlpha = 1;
        }

        /* ---------- Visuals ---------- */
        function drawRival(e) {
            const x = e.x, y = e.y, w = e.w, h = e.h;
            ctx.fillStyle = e.color;
            ctx.beginPath();
            ctx.moveTo(x + w / 2, y);
            ctx.lineTo(x + w, y + h * .75);
            ctx.lineTo(x + w * .7, y + h);
            ctx.lineTo(x + w * .3, y + h);
            ctx.lineTo(x, y + h * .75);
            ctx.closePath();
            ctx.fill();
            const rg = ctx.createRadialGradient(x + w / 2, y + h, 1, x + w / 2, y + h, w * .7);
            rg.addColorStop(0, 'rgba(255,255,255,.85)');
            rg.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = rg;
            ctx.fillRect(x - w / 2, y + h * .6, w * 2, h * .6);
        }

        function drawAce(e) {
            const x = e.x, y = e.y, w = e.w, h = e.h;
            ctx.fillStyle = '#ffd166';
            ctx.beginPath();
            ctx.moveTo(x + w / 2, y);
            ctx.lineTo(x + w * 0.95, y + h * .6);
            ctx.lineTo(x + w * .7, y + h);
            ctx.lineTo(x + w * .3, y + h);
            ctx.lineTo(x + w * 0.05, y + h * .6);
            ctx.closePath();
            ctx.fill();
            for (let i = 0; i < e.hp; i++) {
                ctx.fillStyle = '#ff5c93';
                ctx.fillRect(x + 4 + i * 9, y - 8, 7, 4);
            }
        }

        /* Player & FX (airplane drawing unchanged) */
        function heat() {
            const cx = player.x + player.w / 2, cy = player.y + player.h * 0.9;
            ctx.save();
            ctx.globalAlpha = .18;
            const n = set.low ? 4 : 6;
            for (let i = 0; i < n; i++) {
                const off = i * 8;
                ctx.beginPath();
                ctx.ellipse(cx + Math.sin((performance.now() + off) / 140) * (3 + speed * .8), cy + off, 14, 6, 0, 0, TAU);
                ctx.fillStyle = "rgba(255,255,255,.55)";
                ctx.fill();
            }
            ctx.restore();
        }

        function drawPlayer() {
            if (!player) return;
            const tilt = (player.tx - player.x) * 0.04;
            player.bank += (tilt - player.bank) * 0.18;
            const maxTilt = 3 * Math.PI / 180;
            player.bank = Math.max(-maxTilt, Math.min(maxTilt, player.bank));
            ctx.save();
            const cx = player.x + player.w / 2, cy = player.y + player.h / 2;
            ctx.translate(cx, cy);
            ctx.rotate(player.bank);
            // Main body with gradient and shine
            const bodyGrad = ctx.createLinearGradient(0, -PLAYER_H / 2, 0, PLAYER_H / 2);
            bodyGrad.addColorStop(0, '#d9f1ff');
            bodyGrad.addColorStop(0.5, '#bfe6ff');
            bodyGrad.addColorStop(1, '#a3d1ff');
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.moveTo(0, -PLAYER_H * .58);
            ctx.quadraticCurveTo(PLAYER_W * .24, -PLAYER_H * .15, 0, PLAYER_H * .62);
            ctx.quadraticCurveTo(-PLAYER_W * .24, -PLAYER_H * .15, 0, -PLAYER_H * .58);
            ctx.fill();
            // Cockpit
            ctx.fillStyle = "#4fa6ff";
            ctx.beginPath();
            ctx.ellipse(0, -PLAYER_H * .18, PLAYER_W * .18, PLAYER_H * .22, 0, 0, TAU);
            ctx.fill();
            // Wings with shine
            const wingGrad = ctx.createLinearGradient(0, -PLAYER_H / 2, 0, PLAYER_H / 2);
            wingGrad.addColorStop(0, '#bfe6ff');
            wingGrad.addColorStop(1, '#8fc4ff');
            ctx.fillStyle = wingGrad;
            ctx.beginPath();
            ctx.moveTo(-PLAYER_W * .62, -PLAYER_H * .1);
            ctx.lineTo(PLAYER_W * .62, -PLAYER_H * .1);
            ctx.lineTo(PLAYER_W * .32, PLAYER_H * .18);
            ctx.lineTo(-PLAYER_W * .32, PLAYER_H * .18);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            if (brake) {
                player.smoke++;
                if (player.smoke % 2 === 0) {
                    for (let i = 0; i < 2; i++) parts.push({
                        type: 'smoke',
                        x: player.x + player.w / 2 + (R() - .5) * 10,
                        y: player.y + player.h * .95,
                        r: 6 + R() * 8,
                        a: .55,
                        vx: (R() - .5) * .6,
                        vy: 1.2 + R() * 1.2
                    });
                }
            }
            heat();
        }

        function drawBullets() {
            bullets.forEach(b => {
                if (!isFinite(b.x) || !isFinite(b.y) || !isFinite(b.trail) || b.trail <= 0) return;
                // Glowing red fire bullet effect
                const grad = ctx.createLinearGradient(b.x + 3, b.y, b.x + 3, b.y + b.trail * 3);
                grad.addColorStop(0, b.color);
                grad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(b.x + 1, b.y, 5, b.trail * 3);
                ctx.save();
                ctx.shadowColor = b.glow;
                ctx.shadowBlur = 16;
                ctx.fillStyle = b.color;
                ctx.fillRect(b.x, b.y, b.w, b.h);
                ctx.shadowBlur = 0;
                ctx.restore();
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 1;
                ctx.strokeRect(b.x + 0.5, b.y + 0.5, b.w - 1, b.h - 1);
            });
            ctx.fillStyle = "#ffd166";
            eBullets.forEach(b => {
                ctx.save();
                ctx.shadowColor = "#ffd166";
                ctx.shadowBlur = 10;
                ctx.fillRect(b.x, b.y, b.w, b.h);
                ctx.restore();
            });
        }

        function drawParts() {
            for (let i = parts.length - 1; i >= 0; i--) {
                const p = parts[i];
                if (p.type === 'expl') {
                    ctx.globalAlpha = p.a;
                    ctx.fillStyle = p.col || "#fff";
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r, 0, TAU);
                    ctx.fill();
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vx *= .98;
                    p.vy *= .98;
                    p.a -= .02;
                    p.r *= .995;
                } else if (p.type === 'frag') {
                    ctx.globalAlpha = p.a;
                    ctx.fillStyle = p.col || "#fff";
                    ctx.fillRect(p.x, p.y, p.s, p.s);
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += .1;
                    p.a -= .018;
                } else if (p.type === 'smoke') {
                    ctx.globalAlpha = p.a;
                    ctx.fillStyle = "rgba(255,255,255,.9)";
                    ctx.beginPath();
                    ctx.ellipse(p.x, p.y, p.r * 1.1, p.r * .8, 0, 0, TAU);
                    ctx.fill();
                    p.x += p.vx;
                    p.y += p.vy;
                    p.r *= 1.01;
                    p.a -= .012;
                }
                if (p.a <= 0) parts.splice(i, 1);
            }
            ctx.globalAlpha = 1;
        }

        function explode(e) {
            const col = (e.kind === TYPE.RIVAL || e.kind === TYPE.ACE ? '#ffd4a6' : e.hz === 'ion_pulse' ? '#00ffc8' : '#ff7a5a');
            const n = set.low ? 14 : 22, n2 = set.low ? 6 : 10;
            for (let k = 0; k < n; k++) parts.push({
                type: 'expl',
                x: e.x + e.w / 2,
                y: e.y + e.h / 2,
                r: 3 + R() * 6,
                a: .9,
                vx: (R() - .5) * 4,
                vy: (R() - .5) * 4,
                col
            });
            for (let k = 0; k < n2; k++) parts.push({
                type: 'frag',
                x: e.x + e.w / 2,
                y: e.y + e.h / 2,
                s: 3 + R() * 5,
                a: .8,
                vx: (R() - .5) * 6,
                vy: (R() - .5) * 6,
                col
            });
            if (parts.length > 800) {
                parts.splice(0, parts.length - 800);
            }
            // More frequent and varied pickups from explosions
            if (R() < 0.35) {
                spawnPickupAt(e.x + e.w / 2, e.y + e.h / 2);
            }
        }

        /* Focus & EMP */
        function tickFocus(dt) {
            if (focusOn) {
                focusEnergy = Math.max(0, focusEnergy - dt / 1000);
                if (focusEnergy <= 0) {
                    focusOn = false;
                    sFocus();
                }
            } else focusEnergy = Math.min(1, focusEnergy + dt / 12000);
            el.focusTag.textContent = `Focus: ${Math.round(focusEnergy * 100)}%`;
        }

        function tickEMP(dt) {
            empEnergy = Math.min(1, empEnergy + dt / 9000);
            el.empTag.textContent = `EMP: ${Math.round(empEnergy * 100)}%`;
        }

        function useFocus() {
            if (focusEnergy < 0.2) return;
            focusOn = !focusOn;
            sFocus();
        }

        function useEMP() {
            if (empEnergy < 1) return;
            empEnergy = 0;
            eBullets.length = 0;
            ents.forEach(e => {
                if (e.kind === TYPE.RIVAL || e.kind === TYPE.ACE) e.stun = 1500;
            });
            sEMP();
            toast('EMP!');
            missionHit('emp2', 1);
        }

        /* ---------- Update ---------- */
        let perfectFlow = false;

        function update(dtRaw) {
            const t = performance.now();
            if (dualGun && performance.now() > dualGunExpiry) {
                dualGun = false;
                toast('Dual Guns Expired');
            }
            if (set.low) {
                dtCarry += dtRaw;
                if (dtCarry < 22) return;
                dtRaw = dtCarry;
                dtCarry = 0;
            }
            const dt = focusOn ? dtRaw * 0.75 : dtRaw;
            if (slipT > 0) slipT -= dt;
            if (fogT > 0) fogT -= dt;
            if (Math.abs(windX) > 0.001) windX *= .98;
            if (accel) speed = Math.min(MAX_SPEED, speed + ACCEL * dt);
            if (brake) speed = Math.max(MIN_SPEED, speed - BRAKE * dt);
            if (!accel && !brake) speed = Math.max(BASE_SPEED, speed - 0.0009 * dt);
            const targetZoom = accel ? 1.03 : (focusOn ? 1.02 : 1.0);
            cam.zoom += (targetZoom - cam.zoom) * 0.05;
            if (accel) cam.shake = Math.max(cam.shake, 1 + speed * .1);
            if (cam.shake > 0) cam.shake *= .88;
            if (speed >= HYPERSONIC_SPEED && !sonic) {
                sonic = true;
                sonicT = 900;
                lowpass.frequency.rampTo(3200, .08);
                cam.shake = 18;
                toast('HYPERSONIC!');
                missionHit('speed4000', 1);
                sonicCount++;
            }
            if (sonic) {
                sonicT -= dt;
                if (sonicT <= 0) {
                    sonic = false;
                    lowpass.frequency.rampTo(20000, .25);
                }
            }
            if (ammo < AMMO_MAX && t - lastAmmo > RECHARGE_MS) {
                ammo = AMMO_MAX;
                el.ammo.textContent = ammo;
                lastAmmo = t;
                toast('Ammo Recharged');
            }
            if (t - lastHit > REGEN_DELAY && hp < HP_MAX) {
                hp = Math.min(HP_MAX, hp + REGEN_PER_S * dt / 1000);
                el.hp.style.transform = `scaleX(${hp / HP_MAX})`;
            }
            const steering = (slipT > 0 ? .14 : .22);
            if (player) {
                player.tx = lanesX[player.lane] - player.w / 2 + windX * 40;
                player.x += (player.tx - player.x) * steering;
                player.y = H - PLAYER_H - 56;
            }
            spawnStep(dt);
            patternSpawn(dt);
            radarTarget = null;
            const radarRange = 400;
            for (let i = ents.length - 1; i >= 0; i--) {
                const e = ents[i];
                // Rival AI: Smartly target player's lane
                if (e.kind === TYPE.RIVAL && player && e.y < player.y - 100) {
                    if (e.lane !== player.lane && R() < 0.01 + speed / 2000) {
                        e.targetLane = player.lane;
                        e.lane = player.lane;
                    }
                }
                // Radar detection
                const distY = e.y - (player ? player.y : H);
                if (player && e.kind === TYPE.HZ && distY > 0 && distY < radarRange && e.lane === player.lane) {
                    radarTarget = HAZ[e.hz]?.col;
                    radarDistance = distY;
                }
                if (e.kind === TYPE.PICK) {
                    e.t += dt;
                    e.y += e.vy;
                    e.x += Math.sin(e.t * 0.004) * 0.6;
                    e.a = Math.max(0.25, 1 - e.t / 9000);
                    if (player && aabb(e, player)) {
                        if (e.pk === 'coin') score += 100 * mult;
                        else if (e.pk === 'star') score += 500 * mult;
                        else if (e.pk === 'trophy') score += 5000 * mult;
                        else PICKS[e.pk].apply();
                        ents.splice(i, 1);
                        continue;
                    }
                    if (e.y > H + 30 || e.a <= 0.26) {
                        ents.splice(i, 1);
                        continue;
                    }
                    continue;
                }
                e.y += (e.sp + speed * .35);
                if (e.kind === TYPE.RIVAL && sw.rival.checked && !e.stun) {
                    e.shot = (e.shot || 400) - dt;
                    if (e.shot <= 0 && e.y > 0 && e.y < H) {
                        e.shot = 800 + R() * 900;
                        eBullets.push({x: e.x + e.w / 2 - 3, y: e.y + e.h - 2, w: 6, h: 16, sp: 7 + speed * .9});
                    }
                }
                if (e.kind === TYPE.ACE && !e.stun) {
                    e.shot = (e.shot || 500) - dt;
                    if (e.shot <= 0 && e.y > 0) {
                        e.shot = 500;
                        eBullets.push({x: e.x + e.w / 2 - 9, y: e.y + e.h - 2, w: 6, h: 16, sp: 7 + speed * .9});
                        eBullets.push({x: e.x + e.w / 2 + 3, y: e.y + e.h - 2, w: 6, h: 16, sp: 7 + speed * .9});
                    }
                }
                if (e.kind === TYPE.HZ && HAZ[e.hz]?.up) HAZ[e.hz].up(e, dt);
                if (player && (e.kind === TYPE.RIVAL || e.kind === TYPE.ACE) && e.y + e.h - player.y > 60 && e.y + e.h - player.y < 140 && e.lane === player.lane) {
                    speed = Math.min(MAX_SPEED, speed + 0.003 * dt);
                    draftT = 500;
                    if (R() < 0.02) sPass();
                    missionHit('draft6', 1);
                }
                if (player && aabb(e, player)) {
                    if (e.kind === TYPE.HZ) {
                        if (e.hz === 'splitter' && !e.split) {
                            e.split = true;
                            explode(e);
                            ents.push({
                                ...e,
                                y: e.y + 20,
                                sp: e.sp + 0.5,
                                x: e.x - 15,
                                w: 15,
                                h: 15,
                                dmg: 10,
                                dead: false
                            });
                            ents.push({
                                ...e,
                                y: e.y + 20,
                                sp: e.sp + 0.5,
                                x: e.x + 15,
                                w: 15,
                                h: 15,
                                dmg: 10,
                                dead: false
                            });
                            e.dead = true;
                        } else {
                            damage(HAZ[e.hz]?.dmg || 20);
                            toast(`Notified: Affected by ${e.hz.replace(/_/g, ' ')}`);
                            if (e.hz !== 'train' && e.hz !== 'laserH' && e.hz !== 'rumble' && e.hz !== 'ion_pulse') explode(e);
                            if (e.hz !== 'train' && e.hz !== 'laserH' && e.hz !== 'splitter' && e.hz !== 'ion_pulse') ents.splice(i, 1);
                        }
                    } else if (e.kind === TYPE.RIVAL || e.kind === TYPE.ACE) {
                        damage(e.kind === TYPE.ACE ? 30 : 22);
                        explode(e);
                        if (e.kind !== TYPE.ACE) ents.splice(i, 1);
                    }
                    // Reset combo and flow state on collision
                    weave = 0;
                    mult = 1;
                    perfectFlow = false;
                }
                if (e.y > H + 160 || e.dead) ents.splice(i, 1);
            }
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                if (isNaN(b.x) || isNaN(b.y) || isNaN(b.sp) || isNaN(b.trail)) {
                    bullets.splice(i, 1);
                    continue;
                }
                b.y -= b.sp;
                b.trail = Math.max(0, b.trail - 0.6);
                let hit = false;
                for (let j = ents.length - 1; j >= 0; j--) {
                    const e = ents[j];
                    if (e.kind === TYPE.RIVAL || e.kind === TYPE.ACE || e.kind === TYPE.HZ) {
                        if (aabb(b, e)) {
                            if (e.kind === TYPE.HZ && e.hz === 'shielded' && e.hp > 0) {
                                e.hp--;
                                sColl();
                                if (e.hp <= 0) {
                                    explode(e);
                                    ents.splice(j, 1);
                                    score += 140 * mult;
                                }
                            } else {
                                explode(e);
                                if (e.kind !== TYPE.ACE || --e.hp <= 0) {
                                    ents.splice(j, 1);
                                }
                            }
                            score += (e.kind === TYPE.ACE ? 150 : 120) * mult;
                            sColl();
                            hit = true;
                            break;
                        }
                    }
                }
                if (hit || b.y < -20) bullets.splice(i, 1);
            }
            for (let i = eBullets.length - 1; i >= 0; i--) {
                const b = eBullets[i];
                b.y += b.sp;
                if (player && aabb(b, player)) {
                    damage(18);
                    eBullets.splice(i, 1);
                    continue;
                }
                if (b.y > H + 20) eBullets.splice(i, 1);
            }
            if (parts.length > 800) parts.splice(0, parts.length - 800);
            score += (dt / 100) * (0.7 + speed * .06) * mult;
            if (mult > 1 && performance.now() - comboT > 1500) {
                weave = 0;
                mult = 1;
                perfectFlow = false;
            }
            if (!missions.find(m => m.id === 'speed4000')?.done && speed * 50 >= 4000) missionHit('speed4000', 1);
            tickFocus(dt);
            tickEMP(dt);
            if (sw.ta.checked) {
                timer -= dt;
                el.timer.textContent = Math.max(0, Math.ceil(timer / 1000));
                if (timer <= 0) {
                    gameOver();
                    return;
                }
            }
            if (hp <= 0) {
                gameOver();
                return;
            }
            tickAmbience(speed);
        }

        /* ---------- Render ---------- */
        function vignette() {
            if (!sw.vig.checked) return;
            const g = ctx.createRadialGradient(W / 2, H / 2, Math.min(W, H) * .35, W / 2, H / 2, Math.max(W, H) * .65);
            g.addColorStop(0, 'rgba(0,0,0,0)');
            g.addColorStop(1, 'rgba(0,0,0,.35)');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, W, H);
        }

        function speedBloom() {
            if (!sw.bloom.checked) return;
            const k = Math.min(1, (speed - BASE_SPEED) / (MAX_SPEED - BASE_SPEED));
            if (k <= 0) return;
            const psyFactor = Math.min(1, Math.max(0, (speed - 150) / (MAX_SPEED - 150)));
            const glowAlpha = 0.15 + psyFactor * 0.45;
            const glowSize = (90 * k + 20) + psyFactor * 100;
            ctx.save();
            ctx.globalAlpha = glowAlpha;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(W / 2, H * .65, glowSize, glowSize / 2, 0, 0, TAU);
            ctx.fill();
            ctx.restore();
        }

        function render() {
            const now = performance.now();
            drawBackground(now);
            drawLanes();
            if (accel || speed > BASE_SPEED + 1) {
                const trailSpeed = speed > HYPERSONIC_SPEED ? speed * 2 : speed * 1.6;
                for (let i = 0; i < (set.low ? 1 : 2); i++) lines.push({
                    x: (Math.random() * W) | 0,
                    y: -20,
                    len: 10 + Math.random() * 60,
                    a: .2 + Math.random() * .22,
                    sp: 4 + trailSpeed
                });
            }
            ctx.save();
            if (cam.shake > 0) {
                ctx.translate((Math.random() - .5) * cam.shake, (Math.random() - .5) * cam.shake);
            }
            if (fogT > 0) {
                ctx.globalAlpha = Math.min(.25, fogT / 800 * .25);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, W, H);
                ctx.globalAlpha = 1;
            }
            for (const e of ents) {
                if (e.kind === TYPE.RIVAL) drawRival(e);
                else if (e.kind === TYPE.ACE) drawAce(e);
                else if (e.kind === TYPE.HZ) {
                    if (HAZ[e.hz]?.dr) HAZ[e.hz].dr(e);
                } else if (e.kind === TYPE.PICK) {
                    drawPickup(e);
                }
            }
            if (player) {
                drawPlayer();
            }
            drawBullets();
            ctx.restore();
            for (let i = lines.length - 1; i >= 0; i--) {
                const s = lines[i];
                s.y += s.sp;
                ctx.globalAlpha = s.a;
                ctx.fillStyle = "#fff";
                ctx.fillRect(s.x, s.y, 2, s.len);
                if (s.y > H + 40) lines.splice(i, 1);
            }
            ctx.globalAlpha = 1;
            drawParts();
            if (sonic) {
                const k = 1 - (sonicT / 900);
                const r = (1 - k) * Math.hypot(W, H);
                ctx.save();
                ctx.globalAlpha = .22 * k;
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 8 * k + 2;
                ctx.beginPath();
                ctx.arc(W / 2, H * .62, r, 0, TAU);
                ctx.stroke();
                ctx.restore();
            }
            // Hypersonic glow and psychedelic effect
            const hypersonicFactor = Math.min(1, Math.max(0, (speed - HYPERSONIC_SPEED) / (MAX_SPEED - HYPERSONIC_SPEED)));
            if (hypersonicFactor > 0) {
                ctx.save();
                ctx.globalAlpha = hypersonicFactor * 0.4;
                const g = ctx.createRadialGradient(W / 2, H / 2, 0, W / 2, H / 2, W / 2);
                g.addColorStop(0, '#00e1ff');
                g.addColorStop(1, 'transparent');
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, W, H);
                ctx.restore();
                // Add a subtle wave/distortion effect at max speed
                if (speed > MAX_SPEED * 0.9) {
                    ctx.save();
                    ctx.globalAlpha = Math.min(1, (speed - MAX_SPEED * 0.9) / (MAX_SPEED * 0.1)) * 0.15;
                    const offset = Math.sin(now / 200) * 20;
                    ctx.drawImage(cv, offset, 0, W, H, 0, 0, W, H);
                    ctx.drawImage(cv, -offset, 0, W, H, 0, 0, W, H);
                    ctx.restore();
                }
            }
            if (perfectFlow) {
                ctx.save();
                ctx.globalAlpha = 0.5 * (Math.sin(now / 100) * 0.5 + 0.5);
                const g = ctx.createRadialGradient(W / 2, H / 2, 0, W / 2, H / 2, H * 0.6);
                g.addColorStop(0, 'rgba(0, 255, 120, 0.4)');
                g.addColorStop(1, 'transparent');
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, W, H);
                ctx.restore();
            }
            speedBloom();
            vignette();
            el.score.textContent = Math.floor(score);
            el.spd.textContent = Math.round(speed * 50);
            el.focusTag.textContent = `Focus: ${Math.round(focusEnergy * 100)}%`;
            el.empTag.textContent = `EMP: ${Math.round(empEnergy * 100)}%`;
            // Radar update
            if (radarTarget) {
                el.radarText.textContent = `Threat Detected: ${Math.round(radarDistance)}m`;
                el.radarText.style.color = radarTarget;
                el.radarText.style.textShadow = `0 0 8px ${radarTarget}`;
            } else {
                el.radarText.textContent = 'Radar Clear';
                el.radarText.style.color = 'rgba(255,255,255,0.6)';
                el.radarText.style.textShadow = 'none';
            }
        }

        /* ---------- Loop ---------- */
        let tPrev = 0;

        function loop(t) {
            if (dualGun && performance.now() > dualGunExpiry) {
                dualGun = false;
                toast('Dual Guns Expired');
            }
            if (!running || paused) return;
            const dt = Math.min(32, t - (tPrev || t));
            tPrev = t;
            if (firing) fire();
            update(dt);
            render();
            raf = requestAnimationFrame(loop);
        }

        /* ---------- Controls ---------- */
        document.addEventListener('keydown', e => {
            if (e.repeat) return;
            if (!running && e.code === 'Space') {
                start();
                return;
            }
            if (player) {
                if (e.key === 'ArrowLeft' && player.lane > 0) {
                    player.lane--;
                    lastSwap = performance.now();
                }
                if (e.key === 'ArrowRight' && player.lane < LANES - 1) {
                    player.lane++;
                    lastSwap = performance.now();
                }
            }
            if (e.key === 'ArrowUp') accel = true;
            if (e.key === 'ArrowDown') brake = true;
            if (e.code === 'Space') {
                firing = true;
                fire();
            }
            if (e.key === 'q' || e.key === 'Q') useFocus();
            if (e.key === 'e' || e.key === 'E') useEMP();
            if (e.key === 'Escape') {
                if (el.drawer.classList.contains('open')) closeDrawer();
                else if (running) {
                    openDrawer();
                }
            }
        });
        document.addEventListener('keyup', e => {
            if (e.key === 'ArrowUp') accel = false;
            if (e.key === 'ArrowDown') brake = false;
            if (e.code === 'Space') firing = false;
        });
        // touch (swipe LR to change lanes; swipe up/down = accel/brake; hold 🔫 to fire)
        let t0 = null, moved = false;
        const touchZone = document.body;
        // Fix for pointer events on mobile
        btn.fire.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            firing = true;
            fire();
        });
        btn.fire.addEventListener('pointerup', (e) => {
            e.preventDefault();
            firing = false;
        });
        const handleTouch = (e) => {
            if (!running) return;
            e.preventDefault();
            const rect = game.getBoundingClientRect();
            const clientX = e.clientX || e.changedTouches[0].clientX;
            const clientY = e.clientY || e.changedTouches[0].clientY;
            const normalizedX = (clientX - rect.left) / rect.width;
            const normalizedY = (clientY - rect.top) / rect.height;
            if (normalizedY > 0.8 && (normalizedX < 0.2 || normalizedX > 0.8)) {
                return; // Ignore corner taps to prevent conflicts with buttons
            }
            if (normalizedX < 0.5) {
                if (player && player.lane > 0) {
                    player.lane--;
                    lastSwap = performance.now();
                }
            } else {
                if (player && player.lane < LANES - 1) {
                    player.lane++;
                    lastSwap = performance.now();
                }
            }
        };
        const handleVerticalSwipe = (e) => {
            if (!running) return;
            const t = e.changedTouches[0];
            const dy = t.clientY - (e.touches[0].initialY || t.clientY);
            if (dy < -20) {
                accel = true;
                brake = false;
            } else if (dy > 20) {
                brake = true;
                accel = false;
            } else {
                accel = false;
                brake = false;
            }
        };
        // Use pointer events for cross-platform compatibility
        game.addEventListener('pointerdown', (e) => {
            if (!running || e.target !== cv) return;
            if (e.pointerType === 'touch') {
                e.initialY = e.clientY;
            }
            if (e.pointerType === 'touch' || e.button === 0) {
                if (e.clientX < W/2) {
                    if (player.lane > 0) player.lane--;
                } else {
                    if (player.lane < LANES-1) player.lane++;
                }
            }
            e.preventDefault();
        });
        game.addEventListener('pointerup', (e) => {
            accel = false;
            brake = false;
        });
        game.addEventListener('pointermove', (e) => {
             if (e.pointerType === 'touch' && e.initialY !== undefined) {
                 const dy = e.clientY - e.initialY;
                 if (dy < -20) { accel = true; brake = false; }
                 else if (dy > 20) { brake = true; accel = false; }
                 else { accel = false; brake = false; }
             }
        });
        // Drawer open/close — PAUSE
        function openDrawer() {
            el.drawer.classList.add('open');
            el.scrim.classList.add('show');
            if (running && !paused) {
                paused = true;
                el.paused.classList.add('show');
            }
        }

        function closeDrawer() {
            el.drawer.classList.remove('open');
            el.scrim.classList.remove('show');
            if (paused) {
                paused = false;
                el.paused.classList.remove('show');
                raf = requestAnimationFrame(loop);
            }
        }

        $("#drawerBtn").addEventListener('click', () => {
            if (el.drawer.classList.contains('open')) closeDrawer();
            else openDrawer();
        });
        btn.closeDrawer.addEventListener('click', closeDrawer);
        el.scrim.addEventListener('click', closeDrawer);
        // Help + Mute
        btn.help.addEventListener('click', () => {
            toast('Created by pymn.');
        });
        btn.mute.addEventListener('click', () => {
            Tone.Destination.mute = !Tone.Destination.mute;
            btn.mute.textContent = Tone.Destination.mute ? '🔈' : '🔊';
        });
        // Codes
        btn.apply.addEventListener('click', () => {
            const code = codeIn.value.trim().toUpperCase();
            if (code) {
                mode.code = code;
                mode.daily = false;
                sw.daily.checked = false;
                saveSettings();
                applySeed();
                toast('Challenge code applied');
            }
        });
        btn.gen.addEventListener('click', () => {
            codeIn.value = encodeCode();
            navigator.clipboard?.writeText(codeIn.value).catch(() => {
            });
            toast('Code generated');
        });
        /* ---------- Start / Over ---------- */
        function start() {
            el.gate.style.display = 'none';
            if (!quiet()) {
                armAudio().then(configureSynths);
            }
            reset();
            cancelAnimationFrame(raf);
            running = true;
            paused = false;
            fit();
            raf = requestAnimationFrame(loop);
        }

        function reset() {
            setThemeVars();
            score = 0;
            speed = BASE_SPEED;
            accel = brake = false;
            firing = false;
            mult = 1;
            weave = 0;
            comboT = -1e9;
            AMMO_MAX = 120 + (perks.ammo ? 10 : 0);
            ammo = AMMO_MAX;
            el.ammo.textContent = ammo;
            lastAmmo = performance.now();
            HP_MAX = 100;
            hp = HP_MAX;
            el.hp.style.transform = 'scaleX(1)';
            lastHit = -1e9;
            invTil = 0;
            sonic = false;
            sonicT = 0;
            sonicCount = 0;
            stars = 0;
            focusEnergy = 0;
            empEnergy = 0;
            cam.zoom = 1;
            ents.length = 0;
            bullets.length = 0;
            eBullets.length = 0;
            parts.length = 0;
            lines.length = 0;
            clouds.length = 0;
            ghost.length = 0;
            ghostPlaying.length = 0;
            fogT = 0;
            windX = 0;
            slipT = 0;
            player = makePlayer();
            resize();
            seedClouds();
            el.over.classList.remove('show');
            el.paused.classList.remove('show');
            ghostOn = sw.ghost.checked;
            if (sw.ta.checked) {
                timer = 180000;
                el.timerPill.style.display = 'inline-flex';
            } else {
                el.timerPill.style.display = 'none';
            }
        }

        function gameOver() {
            running = false;
            paused = false;
            cancelAnimationFrame(raf);
            el.final.textContent = Math.floor(score);
            best = Math.max(best, Math.floor(score));
            localStorage.setItem('vel-polished-best', best);
            el.best.textContent = best;
            const gained = Math.floor(score / 500);
            perks.xp += gained;
            if (gained > 0) {
                const newPts = Math.floor(perks.xp / 20);
                if (newPts > perks.pts) perks.pts = newPts;
                savePerks();
                applyPerks();
            }
            el.over.classList.add('show');
        }

        btn.again.addEventListener('click', () => {
            el.over.classList.remove('show');
            start();
        });
        el.gate.addEventListener('click', () => {
            start();
        });
        /* ---------- Boot ---------- */
        if (!missions.length) {
            missions = poolMissions();
        }
        renderMissions();
        applySettingsUI();
        configureSynths();
        applyPerks();
        setThemeVars();
        resize();
        best = +localStorage.getItem('vel-polished-best') || 0;
        el.best.textContent = best;
        fit();
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                accel = false;
                brake = false;
                firing = false;
            }
        });
    })();
</script>
</body>
</html>